<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title id="winTitle">Event</title>

    <th:block th:if="${event != null}">
        <meta property="og:title" th:content="${event.title}"/>
        <meta property="og:date" th:content="${event.termin}"/>
        <meta property="og:description" th:content="${#strings.abbreviate(event.description, 150)}"/>
        <meta property="og:url" th:content="'https://eventbubble.eu/event?id=' + ${event.id}"/>
        <meta property="og:type" content="website"/>
    </th:block>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
</head>
<body>
<script src="/base.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<div id="locationModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4)">
    <div style="
    background:white;
    padding:20px;
    max-width:500px;
    max-height:80vh;
    overflow-y:auto;
    margin:5vh auto;
    border-radius:8px;
">
        <hr>
        <input id="loc_search" placeholder="Search location (city, address, venue)">
        <button onclick="searchLocation()">Search (OSM)</button>
        <div id="loc_results" style="margin-top:8px;"></div>
        <div
                id="loc_map"
                style="height:300px; margin:10px 0; border-radius:6px;"
        ></div>
        <hr>
        <h3>Edit Location</h3>
        <input id="loc_name" placeholder="Display name">
        <input id="loc_street" placeholder="Street">
        <input id="loc_city" placeholder="City">
        <input id="loc_postal" placeholder="Postal code">
        <input id="loc_country" placeholder="Country">
        <input id="loc_lat" type="number" step="any" placeholder="Latitude">
        <input id="loc_lng" type="number" step="any" placeholder="Longitude">
        <hr>
        <button onclick="saveLocation()">Save</button>
        <button onclick="closeLocationEditor()">Cancel</button>
    </div>
</div>

<div th:replace="fragments/header :: header"></div>

<main>
    <section id="create" class="page-width" style="display:none;">
        <div class="box" id="createEvent">
            <h3>Create Event</h3>
            <input id="event_title" placeholder="Title">
            <input id="event_date" type="date">
            <input id="event_time" type="time">
            <textarea id="event_desc" placeholder="Description"></textarea>
            <div class="location-box" id="location_createevent" data-location="">
                <div class="location-summary">
                    <i>No location set</i>
                </div>

                <button onclick="editLocation('location_createevent')">
                    Set / Change Location
                </button>
                <button onclick="clearLocation('location_createevent')">
                    Clear
                </button>
            </div>

            <hr>
            <button onclick="createEventVS()">Create Event</button>
        </div>
    </section>

    <section id="show" class="page-width" style="display:none;">
        <div id="loading" class="box">
            <h1>Loading...</h1>
        </div>

        <div id="invalid" class="box" style="display:none;">
            <h1>Missing or inaccessible event (404)</h1>
        </div>

        <div id="valid" class="box" style="display:none;">

        </div>
    </section>
    <section class="page-width" id="auditSection" style="display:none;">
        <div id="auditLog">

        </div>
    </section>
</main>

<div th:replace="fragments/footer :: footer"></div>

<script>
    const params = new URLSearchParams(window.location.search);
    const eventID = params.get("id");

    if(eventID){
        document.getElementById("show").style.display = "block";
    }else{
        document.getElementById("create").style.display = "block";
    }

    window.addEventListener("load", () => {
        bootstrapSession({
            onAuthenticated:async()=> {
                if(eventID){
                    await loadEvent(eventID);
                }else {

                }
                await loadLatestAuditLogsIfAdmin(`resourceType=EVENT&resourceId=${eventID}`);
            },
            onAnonymous:async()=> {
                if(eventID){
                    await loadEvent(eventID);
                }else{
                    window.location.replace("/login?re=/event");
                }
            }
        });
    });

    EventBubbleBus.addEventListener("auth:logout",async () => {
        setTimeout(() => {
            window.location.replace("/event?id=" + eventID);
        }, 500);
    });

    EventBubbleBus.addEventListener("event:updated",async (e) => {
        notify("Event updated!");
        await loadEvent(eventID);
    });

    EventBubbleBus.addEventListener("event:deleted", () => {
        notify("Event deleted!");
        setTimeout(() => {
            window.location.replace("/event");
        }, 500);
    });

    async function loadEvent(evID){
        if(!evID){
            return;
        }

        const out = document.getElementById("valid");
        out.innerHTML = "";
        const me = await getMe();

        try{
            const ev = await api("/events/"+evID+"?level=full");
            const ownerSnippet = await buildUserSnippet(ev.besitzer);
            const div = renderEvent(ev, ownerSnippet, me);
            div.className = "event";
            out.appendChild(div);

            setLocationInBox(
                `location_event_${ev.id}`,
                ev.location
            );

            document.getElementById("winTitle").innerText = ev.title+" | Eventbubble"

            document.getElementById("loading").style.display = "none";
            document.getElementById("valid").style.display = "block";
        }catch(e){
            notify(e);
            document.getElementById("loading").style.display = "none";
            document.getElementById("invalid").style.display = "block";
        }

        document.getElementById("show").style.display = "block";
        document.getElementById("create").style.display = "none";
    }

    async function createEventVS() {
        try {
            const body = {
                title: event_title.value.trim(),
                description: event_desc.value.trim(),
                termin: buildInstantFromLocal(
                    event_date.value,
                    event_time.value
                ),
                location: getLocationFromBox("location_createevent")
            };

            const res = await api("/events/create", "POST", body);
            notify("Event created!");
            setTimeout(() => {
                window.location.replace("/event?id=" + res.id);
            }, 500);
        } catch (e) {
            notify(e);
        }
    }

    // --------------------------
    // LOCATION
    // --------------------------
    let activeLocationBoxId = null;

    function editLocation(boxId) {
        activeLocationBoxId = boxId;
        document.body.classList.add("modal-open");

        const existing = getLocationFromBox(boxId);

        // Fill inputs (unchanged)
        if (existing) {
            loc_name.value   = existing.displayName || "";
            loc_street.value = existing.street || "";
            loc_city.value   = existing.city || "";
            loc_postal.value = existing.postalCode || "";
            loc_country.value= existing.country || "";
            loc_lat.value    = existing.latitude ?? "";
            loc_lng.value    = existing.longitude ?? "";
        } else {
            document.querySelectorAll("#locationModal input")
                .forEach(i => i.value = "");
        }

        locationModal.style.display = "block";

        setTimeout(() => initLocationMap(existing), 0);
    }

    function initLocationMap(existing) {
        if (!locMap) {
            locMap = L.map("loc_map").setView([52.52, 13.405], 13); // default Berlin

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "Â© OpenStreetMap contributors"
            }).addTo(locMap);

            locMap.on("click", onMapClick);
        }

        if (existing?.latitude && existing?.longitude) {
            setMarker(existing.latitude, existing.longitude);
            locMap.setView([existing.latitude, existing.longitude], 15);
        }
    }

    function setMarker(lat, lng) {
        if (!locMarker) {
            locMarker = L.marker([lat, lng], { draggable: true }).addTo(locMap);
            locMarker.on("dragend", e => {
                const p = e.target.getLatLng();
                updateLatLngInputs(p.lat, p.lng);
            });
        } else {
            locMarker.setLatLng([lat, lng]);
        }

        updateLatLngInputs(lat, lng);
    }

    function updateLatLngInputs(lat, lng) {
        loc_lat.value = lat.toFixed(6);
        loc_lng.value = lng.toFixed(6);
    }

    async function onMapClick(e) {
        const { lat, lng } = e.latlng;
        setMarker(lat, lng);

        const url = new URL("https://nominatim.openstreetmap.org/reverse");
        url.search = new URLSearchParams({
            lat,
            lon: lng,
            format: "json",
            addressdetails: "1"
        });

        const res = await fetch(url);
        const data = await res.json();

        applyReverseGeocode(data);
    }

    function applyReverseGeocode(r) {
        const a = r.address || {};

        loc_name.value =
            a.attraction ||
            a.amenity ||
            a.road ||
            r.display_name ||
            "";

        loc_street.value = [
            a.road,
            a.house_number
        ].filter(Boolean).join(" ");

        loc_city.value =
            a.city ||
            a.town ||
            a.village ||
            "";

        loc_postal.value = a.postcode || "";
        loc_country.value = a.country_code
            ? a.country_code.toUpperCase()
            : "";

        locationModal.dataset.externalSource = "NOMINATIM";
        locationModal.dataset.externalId = r.place_id || null;
    }

    function saveLocation() {
        if (!activeLocationBoxId) return;

        const name = loc_name.value.trim();
        if (!name) {
            notify("Display name required", "warn");
            return;
        }

        const location = {
            displayName: name,
            street: loc_street.value.trim() || null,
            city: loc_city.value.trim() || null,
            postalCode: loc_postal.value.trim() || null,
            country: loc_country.value.trim() || null,
            latitude: loc_lat.value ? parseFloat(loc_lat.value) : null,
            longitude: loc_lng.value ? parseFloat(loc_lng.value) : null,
            externalSource: locationModal.dataset.externalSource || "MANUAL",
            externalId: locationModal.dataset.externalId || null
        };

        setLocationInBox(activeLocationBoxId, location);

        // cleanup
        delete locationModal.dataset.externalSource;
        delete locationModal.dataset.externalId;
        loc_results.innerHTML = "";

        closeLocationEditor();
    }

    function clearLocation(boxId) {
        setLocationInBox(boxId, null);
    }

    async function searchLocation() {
        const q = loc_search.value.trim();
        if (!q) return;

        const url = new URL("https://nominatim.openstreetmap.org/search");
        url.search = new URLSearchParams({
            q,
            format: "json",
            addressdetails: "1",
            limit: "5"
        });

        const res = await fetch(url, {
            headers: {
                "Accept": "application/json"
                // User-Agent is implicitly set by browser
            }
        });

        const results = await res.json();
        renderLocationResults(results);
    }

    let locMap = null;
    let locMarker = null;

    function renderLocationResults(results) {
        const box = document.getElementById("loc_results");
        box.innerHTML = "";

        if (!results.length) {
            box.innerHTML = "<i>No results</i>";
            return;
        }

        results.forEach(r => {
            const div = document.createElement("div");
            div.style.border = "1px solid #ccc";
            div.style.padding = "6px";
            div.style.marginBottom = "4px";
            div.style.cursor = "pointer";
            div.style.background = "#fdfdfd";

            div.innerHTML = `
            <b>${escapeHtml(r.display_name)}</b><br>
            <small>${escapeHtml(r.type || "")}</small>
        `;

            div.onclick = () => applyNominatimResult(r);
            box.appendChild(div);
        });
    }

    function applyNominatimResult(r) {
        const a = r.address || {};

        loc_name.value =
            a.attraction ||
            a.amenity ||
            a.road ||
            r.display_name;

        loc_street.value = [
            a.road,
            a.house_number
        ].filter(Boolean).join(" ") || "";

        loc_city.value =
            a.city ||
            a.town ||
            a.village ||
            a.municipality ||
            "";

        loc_postal.value = a.postcode || "";
        loc_country.value = a.country_code
            ? a.country_code.toUpperCase()
            : "";

        loc_lat.value = r.lat;
        loc_lng.value = r.lon;

        const lat = parseFloat(r.lat);
        const lng = parseFloat(r.lon);
        setMarker(lat, lng);
        locMap.setView([lat, lng], 16);

        // Store external metadata temporarily on modal
        locationModal.dataset.externalSource = "NOMINATIM";
        locationModal.dataset.externalId = r.place_id;
    }

    function closeLocationEditor() {
        activeLocationBoxId = null;
        locationModal.style.display = "none";
        document.body.classList.remove("modal-open");
    }
    document.addEventListener("keydown", e => {
        if (e.key === "Escape") {
            if (locationModal.style.display === "block") {
                closeLocationEditor();
            }
        }
    });
    locationModal.addEventListener("click", e => {
        if (e.target === locationModal) {
            closeLocationEditor();
        }
    });
</script>
</body>
</html>